{"version":3,"sources":["utils.ts","components/Timeline/Timeline.tsx","components/VideoPicker/VideoPicker.tsx","components/Viewer/Viewer.tsx","components/VodSyncApp/VodSyncApp.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["npad","num","size","s","length","formatDate","d","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","parseDuration","m","match","Number","Error","formatDelay","seconds","sign","numbers","Math","floor","splice","map","padStart","join","color","id","Timeline","props","videos","className","Array","from","entries","sort","a","b","startDate","Date","min","getTime","endDate","max","v","duration","e","tsRef","React","createRef","lineHeight","lines","idx","info","key","height","y","x","width","style","fill","position","undefined","currentPosition","type","value","playing","onClick","onPlayingStateChange","preventDefault","onViewersChange","ref","evt","current","bounds","getBoundingClientRect","ratio","clientX","onSeek","VideoPicker","inputRef","handleSubmit","bind","this","video","console","log","onVideoPicked","error","onSubmit","name","placeholder","PureComponent","Viewer","player","delayRef","startTimer","state","initialState","handleVideoPicked","handleDelayChange","reset","startedPlaying","delay","prevProps","prevState","window","clearTimeout","videoDate","videoDuration","pause","seek","play","offset","setTimeout","setState","fetch","headers","clientId","Authorization","accessToken","response","status","json","videoInfo","data","created_at","setVideoInfo","Twitch","Player","autoplay","addEventListener","PLAYING","setPlayerReady","time","nums","slice","n","computeDelay","defaultValue","VodSyncApp","interval","containerRef","handlePlayerStateChange","handleSeek","changeViewers","changePlaying","resized","location","hash","viewers","playerState","Map","innerWidth","setInterval","computeCurrentPosition","clearInterval","removeEventListener","totalW","totalH","innerHeight","bestSquareDiag","bestRows","rows","wt","ceil","ht","w","h","squareDiag","set","delete","videosArray","values","start","end","minOffset","maxOffset","videosBuffering","Set","keys","change","forEach","href","i","push","handlePlayerReady","onChange","App","Boolean","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.0956bb55.chunk.js","sourcesContent":["function npad(num: number, size: number): string {\n  let s = '' + num;\n  while (s.length < size) {\n    s = '0' + s;\n  }\n  return s;\n}\n\nexport function formatDate(d: Date): string {\n  return (\n    d.getFullYear() +\n    '-' +\n    npad(d.getMonth() + 1, 2) +\n    '-' +\n    npad(d.getDate(), 2) +\n    ' ' +\n    npad(d.getHours(), 2) +\n    ':' +\n    npad(d.getMinutes(), 2) +\n    ':' +\n    npad(d.getSeconds(), 2)\n  );\n}\n\nexport function parseDuration(s: string): number {\n  const m = s.match(/(?:([0-9]+)h)?([0-9]+)m([0-9]+)s/);\n  if (!m) {\n    throw Error('Invalid duration');\n  } else if (m[1]) {\n    return Number(m[1]) * 3600 + Number(m[2]) * 60 + Number(m[3]);\n  } else {\n    return Number(m[2]) * 60 + Number(m[3]);\n  }\n}\n\nexport function computeDelay(time: string): number {\n  const m = time.match(/^(-?)(?:(?:([0-9]+):)?([0-9]+)(?:m|min|:))?([0-9]+)?$/);\n  //                     ^  ^^  ^            ^^      ^^          ^^^       ^\n  //                     |  ||  +------------+|      |+----------+|+-------+\n  //                     +--+|     optional   +------+  required  | optional\n  //                     sign|      hours     minutes   delimiter | seconds\n  //                         +------------------------------------+\n  //                                 optional hours+minutes\n  if (!m) {\n    return 0;\n  } else {\n    const sign = m[1] === '-' ? -1 : 1;\n    const nums: number[] = m\n      .slice(2, 5)\n      .map(n => (n !== undefined ? Number(n) : 0));\n    return sign * (nums[0] * 3600 + nums[1] * 60 + nums[2]);\n  }\n}\n\nexport function formatDelay(seconds: number): string {\n  let sign = '';\n  if (seconds < 0) {\n    sign = '-';\n    seconds = -seconds;\n  }\n  const numbers = [\n    // Minutes\n    Math.floor((seconds / 60) % 60),\n    // Seconds\n    seconds % 60,\n  ];\n  // Hours are only shown if non-zero\n  if (seconds >= 3600) {\n    numbers.splice(0, 0, Math.floor(seconds / 3600));\n  }\n  return sign + numbers.map(s => ('' + s).padStart(2, '0')).join(':');\n}\n","import React from 'react';\nimport { formatDate } from '../../utils';\nimport { VideoInfo } from '../../types';\nimport './Timeline.css';\n\ninterface TimelineProps {\n  videos: Map<number, VideoInfo>;\n  currentPosition?: Date;\n  playing: boolean;\n  onSeek: (position: Date) => void;\n  onViewersChange: (change: 1 | -1) => void;\n  onPlayingStateChange: (playing: boolean) => void;\n}\n\nfunction color(id: number) {\n  if (id === 0) {\n    return '#aaf';\n  } else if (id === 1) {\n    return '#faa';\n  } else if (id === 2) {\n    return '#afa';\n  } else if (id === 3) {\n    return '#aff';\n  } else if (id === 4) {\n    return '#faf';\n  } else {\n    return '#ffa';\n  }\n}\n\nexport function Timeline(props: TimelineProps) {\n  if (props.videos.size === 0) {\n    return <div className=\"timestamps\"></div>;\n  }\n  const videos = Array.from(props.videos.entries());\n  videos.sort((a, b) => a[0] - b[0]);\n  const startDate = new Date(\n    Math.min(...videos.map(([i, v]) => v.startDate.getTime()))\n  );\n  const endDate = new Date(\n    Math.max(\n      ...videos.map(([i, v]) => v.startDate.getTime() + v.duration * 1000)\n    )\n  );\n\n  const s = startDate.getTime(),\n    e = endDate.getTime();\n\n  const tsRef: React.RefObject<HTMLDivElement> = React.createRef();\n\n  function handleClick(evt: React.MouseEvent) {\n    if (!tsRef.current) {\n      return;\n    }\n    const bounds = tsRef.current.getBoundingClientRect();\n    const ratio = (evt.clientX - bounds.x) / bounds.width;\n    props.onSeek(new Date(s + (e - s) * ratio));\n  }\n\n  function handlePlayPause() {\n    props.onPlayingStateChange(!props.playing);\n  }\n\n  const lineHeight = 100.0 / videos.length;\n\n  const lines = videos.map(([id, info], idx) => (\n    <rect\n      key={id}\n      height={lineHeight + '%'}\n      y={lineHeight * idx + '%'}\n      x={((info.startDate.getTime() - s) / (e - s)) * 100.0 + '%'}\n      width={(info.duration / (e - s)) * 1000.0 * 100.0 + '%'}\n      style={{ fill: color(id) }}\n    />\n  ));\n\n  let position = undefined;\n  if (props.currentPosition) {\n    position = (\n      <rect\n        height={'100%'}\n        width={'2px'}\n        x={((props.currentPosition.getTime() - s) / (e - s)) * 100.0 + '%'}\n        style={{ fill: 'black' }}\n      />\n    );\n  }\n\n  return (\n    <>\n      <div className=\"buttons\">\n        <input\n          type=\"button\"\n          value={props.playing ? 'pause' : 'play'}\n          onClick={handlePlayPause}\n        />\n        <input\n          type=\"button\"\n          value=\"-\"\n          onClick={e => {\n            e.preventDefault();\n            props.onViewersChange(-1);\n          }}\n        />\n        <input\n          type=\"button\"\n          value=\"+\"\n          onClick={e => {\n            e.preventDefault();\n            props.onViewersChange(1);\n          }}\n        />\n      </div>\n      <div className=\"timestamps\" ref={tsRef} onClick={handleClick}>\n        <svg>\n          {lines}\n          {position}\n        </svg>\n        <div>\n          <div>{formatDate(startDate)}</div>\n          <div>\n            {props.currentPosition\n              ? formatDate(props.currentPosition)\n              : undefined}\n          </div>\n          <div>{formatDate(endDate)}</div>\n        </div>\n      </div>\n    </>\n  );\n}\n","import React from 'react';\n\ninterface VideoPickerProps {\n  onVideoPicked: (video: number) => void;\n}\n\nexport class VideoPicker extends React.PureComponent<VideoPickerProps> {\n  inputRef: React.RefObject<HTMLInputElement>;\n\n  constructor(props: VideoPickerProps) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.inputRef = React.createRef();\n  }\n\n  handleSubmit(evt: React.FormEvent<HTMLFormElement>) {\n    evt.preventDefault();\n    if (this.inputRef.current) {\n      const value = this.inputRef.current.value;\n      const m = value.match(\n        /^(?:https?:\\/\\/(?:www\\.|m\\.)?twitch\\.tv\\/videos\\/)?([0-9]+)(?:\\?.*)?$/\n      );\n      if (m) {\n        const video = Number(m[1]);\n        console.log('Picked video: ', value, ' ', video);\n        this.props.onVideoPicked(video);\n      } else {\n        console.log('Wrong URL: ', value);\n      }\n    } else {\n      console.error('No inputRef');\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"picker\">\n        <form onSubmit={this.handleSubmit}>\n          <input\n            type=\"text\"\n            name=\"video\"\n            ref={this.inputRef}\n            placeholder=\"Twitch video URL\"\n          />\n          <input type=\"submit\" value=\"Watch\" />\n        </form>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport { VideoInfo, PlayerState } from '../../types';\nimport { parseDuration, computeDelay, formatDelay } from '../../utils';\nimport { VideoPicker } from '../VideoPicker/VideoPicker';\nimport './Viewer.css';\n\ninterface ViewerProps {\n  id: number;\n  clientId: string;\n  accessToken: string;\n  state?: PlayerState;\n  setVideoInfo: (id: number, info: VideoInfo | undefined) => void;\n  setPlayerReady: () => void;\n  onChange: (id: number, playerState: PlayerState) => void;\n  width: number;\n}\n\ninterface ViewerState {\n  delay: number;\n  video?: number;\n  videoDate?: Date;\n  videoDuration?: number;\n}\n\nexport class Viewer extends React.PureComponent<ViewerProps, ViewerState> {\n  player?: Twitch.Player;\n  delayRef?: React.RefObject<HTMLInputElement>;\n  startTimer?: number;\n\n  constructor(props: ViewerProps) {\n    super(props);\n    this.state = this.initialState();\n    this.player = undefined;\n    this.delayRef = React.createRef();\n    this.handleVideoPicked = this.handleVideoPicked.bind(this);\n    this.handleDelayChange = this.handleDelayChange.bind(this);\n    this.reset = this.reset.bind(this);\n    this.startedPlaying = this.startedPlaying.bind(this);\n  }\n\n  initialState() {\n    return {\n      delay: 0,\n    };\n  }\n\n  componentDidUpdate(prevProps: ViewerProps, prevState: ViewerState) {\n    // Clear previous timer\n    if (this.startTimer !== undefined) {\n      window.clearTimeout(this.startTimer);\n    }\n    this.startTimer = undefined;\n\n    if (\n      this.props.state &&\n      (this.props.state !== prevProps.state ||\n        this.state.delay !== prevState.delay) &&\n      this.player &&\n      this.state.videoDate &&\n      this.state.videoDuration\n    ) {\n      if (this.props.state.state === 'paused') {\n        this.player.pause();\n        this.player.seek(\n          (this.props.state.position.getTime() -\n            this.state.videoDate.getTime()) /\n            1000.0 +\n            this.state.delay\n        );\n      } else if (this.props.state.state === 'buffering') {\n        this.player.seek(\n          (this.props.state.position.getTime() -\n            this.state.videoDate.getTime()) /\n            1000.0 +\n            this.state.delay\n        );\n        this.player.play();\n      } else if (this.props.state.state === 'playing') {\n        const seek =\n          new Date().getTime() / 1000.0 +\n          this.props.state.offset -\n          this.state.videoDate.getTime() / 1000.0 +\n          this.state.delay;\n        if (seek > this.state.videoDuration) {\n          // After the end - stop playback\n          this.player.pause();\n        } else if (seek < 0.0) {\n          // Before the beginning - stop and set timer to start later\n          this.player.seek(0);\n          this.player.pause();\n          this.startTimer = window.setTimeout(() => {\n            if (this.player) {\n              this.player.seek(0);\n              this.player.play();\n            }\n          }, -seek * 1000);\n        } else {\n          // In range - seek\n          this.player.seek(seek);\n          this.player.play();\n        }\n      }\n    }\n  }\n\n  async handleVideoPicked(video: number) {\n    this.setState({ video });\n\n    // Get video information from API\n    const response = await fetch(\n      'https://api.twitch.tv/helix/videos?id=' + video,\n      {\n        headers: {\n          'Client-ID': this.props.clientId,\n          Authorization: 'Bearer ' + this.props.accessToken,\n        },\n      }\n    );\n    if (response.status === 200) {\n      const json = await response.json();\n      const videoInfo = json.data[0];\n      console.log('Got video date: ', videoInfo.created_at);\n      const videoDate = new Date(videoInfo.created_at);\n      const videoDuration = parseDuration(videoInfo.duration);\n      this.setState({\n        videoDate,\n        videoDuration,\n      });\n      this.props.setVideoInfo(this.props.id, {\n        startDate: videoDate,\n        duration: videoDuration,\n      });\n    }\n\n    // Create player\n    this.player = new Twitch.Player('player' + this.props.id, {\n      width: '100%',\n      height: '100%',\n      video,\n      autoplay: false,\n    });\n    this.player.addEventListener(Twitch.Player.PLAYING, this.startedPlaying);\n    console.log('Created player', this.player);\n  }\n\n  startedPlaying() {\n    if (this.player && this.props.state?.state === 'buffering') {\n      // Pause for now, wait for all videos to be ready\n      this.player.pause();\n      this.props.setPlayerReady();\n    }\n  }\n\n  handleDelayChange(evt: React.FormEvent) {\n    evt.preventDefault();\n    if (this.delayRef?.current) {\n      const delay = computeDelay(this.delayRef.current.value);\n\n      this.setState({\n        delay,\n      });\n      this.delayRef.current.value = formatDelay(delay);\n    }\n  }\n\n  reset() {\n    this.setState({\n      delay: 0,\n      video: undefined,\n      videoDate: undefined,\n      videoDuration: undefined,\n    });\n    this.props.setVideoInfo(this.props.id, undefined);\n  }\n\n  render() {\n    if (this.state.video) {\n      return (\n        <div\n          className=\"viewer\"\n          style={{\n            width: this.props.width + 'px',\n          }}\n        >\n          <div id={'player' + this.props.id} className=\"player\"></div>\n          <div className=\"options\">\n            <form onSubmit={this.handleDelayChange}>\n              Delay:{' '}\n              <input\n                type=\"text\"\n                name=\"delay\"\n                ref={this.delayRef}\n                defaultValue={formatDelay(this.state.delay)}\n              />{' '}\n              <input type=\"submit\" value=\"Set\" />\n            </form>\n            <input type=\"button\" onClick={this.reset} value=\"Reset\" />\n          </div>\n        </div>\n      );\n    } else {\n      return (\n        <div\n          className=\"viewer\"\n          style={{\n            width: this.props.width + 'px',\n          }}\n        >\n          <VideoPicker onVideoPicked={this.handleVideoPicked} />\n        </div>\n      );\n    }\n  }\n}\n","import React from 'react';\nimport './VodSyncApp.css';\nimport { VideoInfo, PlayerState } from '../../types';\nimport { Timeline } from '../Timeline/Timeline';\nimport { Viewer } from '../Viewer/Viewer';\n\nconst TWITCH_CLIENT_ID = 'r69vc9claq1m3n960hrkuszot4nx54';\n\n// Assumed aspect ratio\nconst ASPECT_RATIO = 16.0 / 9.0;\n\nconst MAX_VIEWERS = 6;\n\ninterface VodSyncAppProps {}\n\ninterface VodSyncAppState {\n  accessToken: string | null;\n  viewers: number;\n  playerState: PlayerState;\n  currentPosition?: Date;\n  videos: Map<number, VideoInfo>;\n  width: number;\n}\n\nexport class VodSyncApp extends React.PureComponent<\n  VodSyncAppProps,\n  VodSyncAppState\n> {\n  interval?: number;\n  containerRef: React.RefObject<HTMLDivElement>;\n\n  constructor(props: VodSyncAppProps) {\n    super(props);\n    this.state = this.initialState();\n    this.containerRef = React.createRef();\n    this.setVideoInfo = this.setVideoInfo.bind(this);\n    this.handlePlayerStateChange = this.handlePlayerStateChange.bind(this);\n    this.handleSeek = this.handleSeek.bind(this);\n    this.changeViewers = this.changeViewers.bind(this);\n    this.changePlaying = this.changePlaying.bind(this);\n    this.resized = this.resized.bind(this);\n    window.addEventListener('resize', this.resized);\n  }\n\n  initialState(): VodSyncAppState {\n    const match = window.location.hash.match(/#access_token=([^&]+)/);\n    let accessToken = null;\n    if (match && match[1]) {\n      accessToken = match[1];\n      console.log('Got access token: ', accessToken);\n    }\n    return {\n      accessToken,\n      viewers: 2,\n      playerState: {\n        state: 'paused',\n        position: new Date(1),\n      },\n      videos: new Map(),\n      width: window.innerWidth / 2 - 14,\n    };\n  }\n\n  componentDidMount() {\n    this.resized();\n    this.interval = window.setInterval(\n      this.computeCurrentPosition.bind(this),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    if (this.interval !== undefined) {\n      window.clearInterval(this.interval);\n      this.interval = undefined;\n    }\n    window.removeEventListener('resize', this.resized);\n  }\n\n  resized() {\n    this.setState(state => {\n      // Measure the space we have to fill\n      let totalW = window.innerWidth;\n      let totalH = window.innerHeight - 20;\n      if (this.containerRef.current) {\n        const size = this.containerRef.current.getBoundingClientRect();\n        totalW = size.width;\n        totalH = size.height;\n      }\n      // Find the number of rows to use\n      // We pick the one with the best diagonal for videos\n      let bestSquareDiag = 0.0;\n      let bestRows = 1;\n      for (let rows = 1; rows <= state.viewers; ++rows) {\n        const cols = Math.ceil(state.viewers / rows);\n        // Size of the area for each viewer, if we get this number of rows\n        const wt = totalW / cols - 14;\n        const ht = totalH / rows - 6 - 33;\n        // Size of this area with the right aspect ratio\n        const w = Math.min(wt, ht * ASPECT_RATIO);\n        const h = Math.min(ht, wt / ASPECT_RATIO);\n        // Compute the diagonal and update the best value\n        const squareDiag = w * w + h * h;\n        if (squareDiag > bestSquareDiag) {\n          bestSquareDiag = squareDiag;\n          bestRows = rows;\n        }\n      }\n      const columns = Math.ceil(state.viewers / bestRows);\n      return {\n        width: totalW / columns - 14,\n      };\n    });\n  }\n\n  setVideoInfo(id: number, info: VideoInfo | undefined) {\n    console.log('setVideoInfo: ', id, ', ', info);\n    this.setState(state => {\n      const videos = new Map(state.videos);\n      if (info) {\n        videos.set(id, info);\n      } else {\n        videos.delete(id);\n      }\n\n      // Update the player state to fall within at least one video\n      let playerState = state.playerState;\n      if (state.videos.size > 0) {\n        const videosArray = Array.from(state.videos.values());\n        const start = Math.min(...videosArray.map(v => v.startDate.getTime()));\n        const end = Math.max(\n          ...videosArray.map(v => v.startDate.getTime() + v.duration * 1000)\n        );\n        if (this.state.playerState.state === 'paused') {\n          if (this.state.playerState.position.getTime() < start) {\n            playerState = {\n              state: 'paused',\n              position: new Date(start),\n            };\n          } else if (this.state.playerState.position.getTime() > end) {\n            playerState = {\n              state: 'paused',\n              position: new Date(end),\n            };\n          }\n        } else if (this.state.playerState.state === 'playing') {\n          const minOffset = (start - new Date().getTime()) / 1000.0;\n          const maxOffset = (end - new Date().getTime()) / 1000.0;\n          if (this.state.playerState.offset < minOffset) {\n            playerState = {\n              state: 'playing',\n              offset: minOffset,\n            };\n          } else if (this.state.playerState.offset > maxOffset) {\n            playerState = {\n              state: 'playing',\n              offset: maxOffset,\n            };\n          }\n        }\n      }\n      return { videos, playerState };\n    });\n  }\n\n  handlePlayerStateChange(id: number, playerState: PlayerState) {\n    // TODO: Handle unexpected state change in players\n  }\n\n  computeCurrentPosition() {\n    this.setState(state => {\n      let currentPosition;\n      if (\n        state.playerState?.state === 'paused' ||\n        state.playerState?.state === 'buffering'\n      ) {\n        currentPosition = state.playerState.position;\n      } else if (state.playerState?.state === 'playing') {\n        currentPosition = new Date(\n          new Date().getTime() + state.playerState.offset * 1000.0\n        );\n      } else {\n        return {};\n      }\n      return { currentPosition };\n    });\n  }\n\n  handleSeek(position: Date) {\n    // Go to buffering state\n    this.setState({\n      playerState: {\n        state: 'buffering',\n        position,\n        videosBuffering: new Set(this.state.videos.keys()),\n      },\n    });\n  }\n\n  handlePlayerReady(id: number) {\n    const playerState = this.state.playerState;\n    if (playerState.state === 'buffering') {\n      const { position, videosBuffering } = playerState;\n      videosBuffering.delete(id);\n      if (videosBuffering.size === 0) {\n        const offset = (position.getTime() - new Date().getTime()) / 1000.0;\n        this.setState({\n          playerState: {\n            state: 'playing',\n            offset,\n          },\n        });\n      }\n    }\n  }\n\n  changeViewers(change: 1 | -1) {\n    this.setState(state => {\n      const viewers = Math.max(\n        1,\n        Math.min(MAX_VIEWERS, state.viewers + change)\n      );\n      const videos = new Map();\n      state.videos.forEach((info, id) => {\n        if (id < viewers) {\n          videos.set(id, info);\n        }\n      });\n      return {\n        viewers,\n        videos,\n      };\n    });\n    this.resized();\n  }\n\n  changePlaying(playing: boolean) {\n    if (playing && this.state.playerState.state === 'paused') {\n      this.setState({\n        playerState: {\n          state: 'playing',\n          offset:\n            (this.state.playerState.position.getTime() - new Date().getTime()) /\n            1000.0,\n        },\n      });\n    } else if (!playing && this.state.playerState.state === 'playing') {\n      this.setState({\n        playerState: {\n          state: 'paused',\n          position: new Date(\n            new Date().getTime() + this.state.playerState.offset * 1000.0\n          ),\n        },\n      });\n    }\n  }\n\n  render() {\n    if (!this.state.accessToken) {\n      setTimeout(() => {\n        window.location.href =\n          'https://id.twitch.tv/oauth2/authorize?client_id=' +\n          TWITCH_CLIENT_ID +\n          '&redirect_uri=https://remram44.github.io/twitch-vod-sync/&response_type=token&scope=';\n      }, 2000);\n      return <p>Redirecting you to Twitch to authorize use of their API...</p>;\n    }\n\n    const viewers = [];\n    for (let i = 0; i < this.state.viewers; ++i) {\n      viewers.push(\n        <Viewer\n          id={i}\n          key={i}\n          clientId={TWITCH_CLIENT_ID}\n          accessToken={this.state.accessToken}\n          state={this.state.playerState}\n          setVideoInfo={this.setVideoInfo}\n          setPlayerReady={() => this.handlePlayerReady(i)}\n          onChange={this.handlePlayerStateChange}\n          width={this.state.width}\n        />\n      );\n    }\n\n    return (\n      <div className=\"view-container\" ref={this.containerRef}>\n        <div className=\"videos\">{viewers}</div>\n        <div className=\"timeline\">\n          <Timeline\n            currentPosition={this.state.currentPosition}\n            playing={this.state.playerState.state !== 'paused'}\n            videos={this.state.videos}\n            onSeek={this.handleSeek}\n            onViewersChange={this.changeViewers}\n            onPlayingStateChange={this.changePlaying}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport { VodSyncApp } from './components/VodSyncApp/VodSyncApp';\n\nexport function App() {\n  return <VodSyncApp />;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ninterface Config {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('app')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}